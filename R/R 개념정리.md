# 1. R 개념 정리

## 1) R에서의 데이터 종류(타입)

### (1) 자료형

#### ① 문자형(character)

문자형(character) : 문자, 문자열

여러개의 문자로 구성되어 있어도, 하나의 문자여도 문자형으로 통일된다.



#### ② 수치형(numeric)

수치형(numeric) : 정수(integer) + 실수(double)



#### ③ 복소수형(complex)

복소수형(complex) : 실수 + 허수



#### ④ 논리형(logical) 

**파이썬**은 **True**, **자바스크립트**는 **true**, **R**은 **TRUE**







### 2) 리터럴

#### ① 문자형(character) 리터럴

```R
"가나다"
'가나다'
""
''
'123'
"abc"
```



#### ② 수치형(numeric) 리터럴

```R
100
3.14
0
```



#### ③ 논리형(logical) 리터럴

```R
TRUE(T)
FALSE(F)
```



#### ④ NULL

`NULL` : <u>데이터 셋이 비어있음</u> -> 데이터 셋 자체가 없는 경우



#### ⑤ NA

`NA` : 데이터셋의 내부에 존재하지 않는 값 -> 세부적으로 값이 없는 경우, 데이터 셋의 5번째에는 값이 없는 경우(**결측치**)



#### ⑥ NaN / Inf

`NaN` : 숫자가 아님

`Inf `: 무한대 값



### 3) 타입체크 함수

> 타입 체크 함수를 통해 X 변수의 값이 어떠한 타입인지 확인할 수 있다.

is.character : 문자형

is.logical - 논리형



### 4) 자동형변환 규칙

문자형(character) >복소수형(complex) >수치형(numeric) > 논리형(logical)



* 문자와 복소수를 연산하면 문자가 된다.

* 수치와 논리형을 연산하면 수치가 된다.

  

### 5) 강제 형변환 함수

강제형변환 함수 (as. )

as.character(x)            

as.complex(x)      

as.numeric(x)              

as.double(x)                       

as.integer(x)              

as.logical(x)



### 6) 자료형 / 구조 확인 함수

class(x)

str(x)

mode(x)

typeof(x)



## 2) R로 다룰 수 있는 데이터셋의 종류

R은 통계분석 tool 인 만큼, 여러 데이터를 묶고 처리하는 경우가 많다.

`데이터의 종류와 구조` 등에 따라서 **벡터, 행렬, 배열, 데이터프레임, 리스트**의 데이터셋을 만든다.



![](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F230EBE375672CF0337)



<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABRcAAAFCCAIAAADkK31FAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAGC7SURBVHhe7b190GVleadLlXU8/nPmjzk5pVWnMsmpmipTp+YYBbqxSbd0gzQydqYDyjgok/YLRiTo0Rg1BHU0wWOIZzBqUNQEP0i0HGMcavAIRg0GNeI3Tlt8KAQUhABiGhpEQzy/5n699/Jez1697r2evXqz9nXXVVTz7LXXWnute//Wc+213/c97KcURVEURVEURVEURfUrLJqiKIqiKIqiKIqi+hYWTVEURVEURVEURVF9C4umKIqiKIqiKIqiqL6FRVMURVEURVEURVFU38KiKYqiKIqiKIqiKKpvYdEURVEURVEURVEU1bewaIqiKIqiKIqiKIrqW1g0RVEURVEURVEURfUtLJqiKIqiKIqiKIqi+hYWTVEURVEURVEURVF9C4umKIqiKIqiKIqiqL6FRVMURVEURVEURVFU38KiKYqiKIqiKIqiKKpvYdEURVEURVEURVEU1bcOYtEP/fNPv3/Pgzfe8cA3/v6+z1/3jwAH5Ws33fvt2x+47Qc/+vFP/nmjjVam7vvRP92578c33/mjvd/dH3YbAGAZfPOW+3QN1ZV03/3/tJFEyy+yDgCmQd0INa+56R9+pNWGDQHMQxZcVJsui1a/yojCigB6cvUN++744YMbzXSoS33/re8xmwSAQ4kuqct2abIOAKbKwAjFa2AgQW3mWrRa7e+uP/CEr92477a77vvHfff/9Cc/Ajgo++594Pt37//mzfus4VZBpO+57yfqe+2MWvra7913yz/sVz//5MEHwp4DAFRHaaNr6Ldvu+9L39m4DH/v7h9tZFPtIusAYGLUitCm13zvzgNe89CP47YAisxTm7JFP/TPP7VPa9S1NBkshiZwaiFN6Q7tV7vv3Pdja3p1//33M5sEgEODbFaXVIujm++sL9JkHQBMmCERitdAFYLalC36+/c8qIW+duM+Wg2G8K3vPpxZtz+w0Vijl7rc7szcdPv+sG8AAONz9w83vm5d96vdZB0ArAOLRSheA7Voqk3Zoq+/7X4tcccPuBjDIO7bf6CRvvH392001uhlPx/4zZv3hR0DADhU3HzHgVz62k33PlTvazpkHQCs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" style="zoom:150%;" />





### (1) 벡터

가장 기초적인 데이터셋으로, 1차원으로 사용된다.

기본적으로 열 벡터이다. (출력은 하나의 행처럼 보임)

R은 스칼라는 존재하지 않는다.(하나의 데이터 값도 벡터로 취급되어 길이가 1인 벡터로 취급된다.)

인덱스는 1부터 시작한다. [인덱스]

동일 타입의 데이터로만 구성되어, 다른 타입의 데이터가 저장될 시에 문자형 > 수치형 > 논리형 의 규칙에 따라 저장된다.



#### ① 벡터 생성 방법

```R
# c() 함수는 아규먼트를 원하는 만큼 전달할 수 있다.
v1 <- c(5,2,6,7,1)

# seq() 함수는 range와 비슷한 성질을 갖는다. 
v2 <- seq(1,9,by=2)

# rep() 함수는 데이터 값을 몇 번 반복할지 정하여 데이터셋을 만든다.
v3 <- rep(1,100)
v4 <- rep(1:3,5) # 123의 묶음이 5번씩 반복된다
v5 <- rep(1:3,times=5) # 123의 묶음이 5번씩 반복된다
v6 <- rep(1:3,each=5) # 1,2,3 이 각각 5번씩 반복된다

# :는 1씩 증가하거나 1씩 감소하여 데이터셋을 만들 때 사용한다.
v7 <- 1:10
v8 <- 10:1
```



#### ② 값이 내장된 상수 벡터

`LETTERS`

`letters`

`month.name`

`month.abb`

`pi`



#### ③ 주요 함수

```R
# 원소 개수
length()

# 벡터의 요소마다 이름을 부여하는 경우 -> 숫자 인덱스 대신 문자 인덱스를 통해 추출
names()

# 정렬 (원소의 자리바꿈)
sort()

# 정렬 (원소 값을 비교하여, 인덱스로 리턴함) : 데이터 프레임의 정렬에 유용하게 사용됨
order()
```







### (2) 행렬(matrix)

2차원의 벡터이며, 동일타입의 데이터만 저장 가능하다.

할당할 수 있는 값이 정해진 요인



#### ① 인덱싱

```R
[행의 인덱싱, 열의 인덱싱]

[행의 인덱싱, ]

[, 열의 인덱싱]

```



#### ② drop 속성

열을 유지해야할 필요가 없는 경우, 하나의 열, 하나의 행인 경우에는 2차원 구조를 깨뜨리는 것이 기본인데

이것이 싫으면 2차원의 행렬구조를 유지하도록 할 수 있다. 



#### ③ 행렬 생성 방법

##### ⓐ matrix 함수 이용
###### ⓐ -1. 행 우선 채우기

```R
  matrix(data=벡터, nrow=행의갯수, ncol=열의갯수)
  
  matrix(data=벡터, nrow=행의 개수, ncol =열의 개수, byrow=FALSE)
```

```R
x1 <-matrix(data=1:8, nrow = 2)
# data는 생략 가능 x1 <-matrix(1:8, nrow = 2)
>> 결과 : 열단위로 먼저 채워진다.
      [,1] [,2] [,3] [,4]
[1,]    1    3    5    7
[2,]    2    4    6    8
```



###### ⓐ -2. 열 우선 채우기

```R
    matrix(data=벡터, nrow=행의갯수, ncol=열의갯수, byrow=TRUE)
```

|||





##### ⓑ rbind, cbind 함수 이용

###### ⓑ -1. 행 우선 채우기

```R
rbind (행렬 들 )
```



###### ⓑ -2. 열 우선 채우기

```R
cbind(행렬 들)
```



#### ④ 주요 함수

`dim(m)` - 행렬이 몇 차원인지 체크

`nrow(행렬)` - 행의개수

`ncol(행렬)` - 열의 개수

`colnames(m) `- 행 이름 

`rownames(m)` - 열 이름

`rowSums(m)`

`colSums(m)`

`rowMeans(m)`

`colMeans(m)`

`apply(m,1또는 2,함수)`: 함수에 함수를 불러옴 (1 : 행단위 함수 전달 및 호출 , 2 : 열 단위 함수전달 및 호출)

`sum(m)` : 행렬의 모든 원소에 대한 연산

`mean(m)`



### (3) 배열(array)

1, 2, 3, 4차원을 지원한다. 3차원 이상의 경우 배열을 사용한다. (1,2 차원의 경우에는 벡터와 행렬을 주로 이용)

3차원은 여러 개의 matrix를 갖는 형태이다.

**동일한 타입의 데이터**를 저장할 수 있다. (벡터, 행렬, 배열의 공통점)



#### ① 인덱싱

행의 인덱싱, 열의 인덱싱, 면(층)의 인덱싱





### (4) 팩터(factor)

정해진 **범주의 값**으로만 구성되는 벡터 (범주형 데이터)

학생들의 몸무게는 값이 굉장히 다양하여 팩터로 구성할 수 없다. 하지만 초등학생의 학년 (1,2,3,4,5,6)의 경우는 정해진 범주가 있기 때문에 팩터로 구성할 수 있다.



API 중 숫자, 문자, 팩터에 따라 결과가 달라지는 경우가 있기 때문에 팩터에 대한 학습이 필요하다.

(팩터는 `summary`를 할 때 **개수**를 세준다. )



##### ① 생성방법

> 범주형 데이터는 질적 자료로 측정 대상의 특성을 분류하거나 확인할 목적으로 부여한 값으로 값들의 순서 적용 여부에 따라서 명목형과 순서형으로 나뉜다.



`factor(벡터)`

`factor(벡터[, levels=레벨벡터])`

`factor() : 명목형`

`ordered = TRUE 순서형 `

```R
score <- c(1,3,2,4,2,1,3,5,1,3,3,3)
f_score <- factor(score) # 팩터 형으로 바꿔줌 
summary(f_score)
levels(f_score)

> f_score
 [1] 1 3 2 4 2 1 3 5 1 3 3 3
Levels: 1 2 3 4 5

> summary(f_score)
1 2 3 4 5 
3 2 5 1 1 

> levels(f_score)
[1] "1" "2" "3" "4" "5"
```





##### ② 레벨 정보 추출

값의 범주를 나타낸다.





### (5) 데이터 프레임

정형 데이터의 경우 주로 '데이터 프레임'을 사용한다.

열 단위로 벡터가 묶어져 있으며, 모든 열의 데이터 개수는 동일해야 한다.

열 단위마다 **서로 다른 유형**의 데이터 타입을 가질 수 있다.

**모든 열의 데이터 개수(행의 개수)는 동일해야 한다.**



ex : csv 파일



##### ① 생성방법

`data.frame(벡터들)` : 열이름은 벡터의 이름으로 자동으로 적용된다.

`data.frame(열이름 = 벡터,)`

자동으로 펙터형.

**stringAsFactors= False 가 기본값임** ]) # 4.0 이전에는 T가 기본 4.0 부터는 F 가 기본

문자열 벡터는 자동으로 펙터로 만들었던 과거 버전. 현재는 아님 false 가 기본..





##### ② 데이터 프레임 변환

`cbind(df, 벡터)` : 없었던 열을 새로 붙이는 경우

`rbind(df, 벡터)` : 없었던 행을 새로 붙이는 경우



##### ③ 데이터 프레임 구조 확인

`str(df)` : 주로 사용된다. 

`dim(df)` : 몇 행 몇 열인지만 알고 싶을 때



##### ④ 인덱싱

`[행의 인덱싱, 열의 인덱싱]`

`[열의 인덱싱]` : 데이터 프레임은 열 단위의 데이터처리가 일반적이기 때문에 대괄호에 컬럼이름, 컬럼 숫자를 하나만 작성할 경우 열의 인덱싱을 인식한다.

`df$컬럼이름` : $는 파이썬의 member 연산자(.)와 동일한 역할을 한다. 

`[[열인덱싱]]`



##### ⑤ 원하는 행, 열의 추출

###### ⓐ 인덱스에 조건식



###### ⓑ subset(df,select=컬럼명들, subset=(조건))

```R
subset(emp,select = c(ename, job, sal)) #subset 함수의 사용

```





### (6) 리스트 : 데이터 셋을 묶는 역할

**모든 유형의 객체집합**으로 **서로 다른 유형의 데이터셋을 하나로 묶고자 할 때** 사용하며 **가장 자유로운 데이터셋**이다. 

데이터의 집합을 다루는 용도보다는 **"데이터셋을 다루는 용도"**로 쓰인다.

**저장 가능한 데이터의 타입, 데이터셋의 종류에 제한이 없어**, 벡터, 행렬, 배열, 데이터프레임, 리스트, 함수 등의 데이터를 저장할 수 있다. 

리스트는 벡터연산을 지원하지 않기 때문에, 벡터연산을 사용해야 할 때는 `unlist()`를 사용하여 **리스트를 벡터로 반환**하여 리스트를 해제하는 함수를 사용한다.



리스트(List)는 배열과 비교할 때 데이터를 중간 중간에 삽입하는 데 유리한 구조로 설명한다. 물론 그러한 장점은 동일하지만 R에서 리스트는 데이터를 접근한다는 관점에서 다른 언어의 해시 테이블 또는 딕셔너리로 종종 설명된다. 즉, 리스트는 ‘(키, 값)’ 형태의 데이터를 담는 연관 배열Associative Array이다.



또 다른 리스트의 특징은 벡터와 달리 값이 서로 다른 데이터 타입을 담을 수 있다는 점이다. 따라서 “이름”이라는 키에 “홍길동”이라는 문자열 값을 저장하고, “성적”이라는 키에 95라는 숫자 값을 저장할 수 있다.



`[ ]` : 리스트가 포함한 하위 리스트를 뽑아낸다.

`[[ ]] ` `$`: 리스트가 아니라 실제 데이터 값을 추출해낸다.



#### ① 리스트 생성

`list()`를 통해 생성할 수 있다.

````R
a <- list(
		 	a = 1:3,
		 	b = "a string",
		 	c = pi,
		 	d = list(-1,-5)
		 	)
````



![](https://sulgik.github.io/r4ds/diagrams/lists-subsetting.png)



리스트가 아니라 벡터로 출력하고 싶을 때는 대괄호 2개 해야 함



## 3) R의 연산자


![](https://img1.daumcdn.net/thumb/R720x0.q80/?scode=mtistory2&fname=http%3A%2F%2Fcfile3.uf.tistory.com%2Fimage%2F187E2A484F646545229368)

### (1) 논리 연산자

`&` 는 원소마다 비교 . 벡터 연산 

`&&` 는 첫번째 원소로만 비교한다.

**즉, 비교 대상이 많은 경우 무조건 하나짜리를 쓴다.** 







## 4) R의 데이터 출력

콘솔화면에 데이터를 출력하는 함수

### (1) print

데이터셋, 데이터를 출력

하나뿐.

```R
print(출력 데이터 [, 옵션들])
```



### (2) cat

메시지를 출력할 때

출력할 데이터 값들(숫자, 논리, 문자형 데이터 값)을 원하는 만큼 하나의 행으로 출력할 수 있다.

```R
cat(..., 옵션들 ...)
```









## 5) R의 제어문

조건에 따라 수행하도록 할 때

### (1) if

```R
if(조건)
	수행 명령 문장
```



```R
if(조건1)
	수행 명령문장1
else if(조건2)
    수행 명령문장2
else if(조건3)
    수행 명령문장3
else {
	수행 명령문장4
	수행 명령문장5
}

# 수행 명령 문장이 2개 이상일 때는 { } (블럭)으로 구성한다.
```



### (2) ifelse

데이터를 추가하는 경우에 유용하게 쓰인다. 

```R
ifelse(조건, 조건이 참일 때의 명령문1, 조건이 거짓일 때의 명령문 2)
```



### (3) switch

```R
switch(EXPR = 수치 데이터, 식1, 식2, 식3,...)
switch(EXPR = 문자열 데이터, 비교값 1 = 식 1, 비교값 2 = 식 2 ...)
```

식의 결과값에 따라 처리를 할 때 는 switch 함수를 쓰는게 매우 유용하다.



### (4) for

```R
for (변수 in 데이터셋)
	수행명령문장
# 데이터셋의 데이터 개수만큼 for문이 반복된다.
```



### (5) while

어떠한 조건에 따라 반복을 할 때

```R
while (조건)
	수행명령문장
```



### (6) repeat /  break

`whilte true`와 동일하다. (무한루프)

```R
repeat 명령문
```



`break`는 반복문을 종료하는 역할



### (7) next

`continue`와 비슷하다. 

반복문 내에서는 화면에 결과를 출력할 때 출력함수(`print`, `cat`)를 반드시 사용해야 한다.











## 6) 함수

R 프로그램의 주요 구성 요소로 특정 작업을 독립적으로 수행하는 프로그램 코드 집합이다.

함수를 사용하게 되면, 반복적인 연산은 효과적으로 할 수 있다.



### (1) 함수의 처리

1. **시작(입력)** : 매개변수를 통해 아규먼트값을 받아옴
2. **실행(연산)** : 연산, 변환 등
3. **종료(출력)** : 수행결과를 데이터셋으로 반환/출력



### (2) 함수 정의

`function` 예약어를 통해 함수를 만든다. 

함수명에 담는 형식으로 

[매개변수] 선택적

{ 함수 수행 코드 } : 2개 이상인 경우에는 꼭 중괄호로 묶는다.

리턴값이 없더라도 리턴함수를 이용하여 return() 으로 값을 생략하는 것이 좋다. 



```R
함수명<- function([매개변수]) {
	함수의 수행 코드(수행명령문장들..)
	[ return(리턴하려는값) ]
}
```






### (3) 함수 호출

```R
변수명 <- 함수명()
변수명 <- 함수명(아규먼트)
함수명()
함수명(아규먼트)
```

```R
# f1 함수 생성
f1 <- function() print("TEST")	

# 받을 아규먼트가 없으면 빈괄호()를 붙인다.
# 하나의 줄의 수행코드를 갖는 경우 { }(중괄호)를 생략할 수 있다.



# f1 함수 호출
f1()
```



```R
# f2 함수 생성
f2 <- function(num) {print("TEST"); print(num) }	        

# 두 개 이상의 수행 코드의 경우 { } 중괄호는 필수이다.


# f2 함수 호출
f2(100)
f2(100, 200)
f2() # 오류 발생
```



```R
# f3 함수 생성
# p = "R"의 기본값을 갖는 f3함수
f3<- function (p="R") print(p)			        


# f3 함수 호출
#자동으로 R이 쓰인다.
f3()

#아규먼트 전달
f3(p="PYTHON") // 키워드 아규먼트
f3("java")
```



```R
# f4 함수 생성
# 매개변수 p1,p2를 갖는 f4함수 . p1은 기본값이 있다.
f4<- function (p1="ㅋㅋㅋ",p2) for(i in 1:p2) print(p1)
			                          

# f4 함수 호출
f4(p1="abc", p2=3)
f4("abc", 3) # 포지셔널 아규먼트 
             # (첫번째 아규먼트는 첫번째 매개변수로 두번째 아규먼트는 두번째 매개변수로)
f4(5) # 에러 
f4(,5)
f4(p2=5) 
```







### (4)  R 함수의 특징

* 호출 시 함수가 정의하고 있는 **매개변수(기본값이 없는) 사양**에 맞춰서 **아규먼트를 전달**해야 한다.

  

* 리턴값이 없는 함수는 `NULL` 이 리턴된다.

* 리턴값은 `return()` 이라는 함수를 호출하여 처리한다. 

  return() 문이 생략된 경우에는 마지막으로 출력된 데이터값이 자동으로 리턴된다. 

  가급적 **리턴함수를 사용하여 명확히 구현하는 것이 필요**하다. (아무것도 return 하고 싶지 않을 때에도 return() 은 적어주는 것이 필요하다) 

  

* 아규먼트의 타입을 제한하려는 경우에는 함수 수행 코드 내에서 `is.xxxx()` 함수를 활용한다.

  ```R
  l <- list(1,2,3)
  v <- c(1,2,3)
  
  sum(v)
  sum(l) # Error in sum(l) : 인자의 'type' (list)이 올바르지 않습니다.
  ```

  즉, sum 함수는 리스트의 경우에 type이 제한되어 있다는 뜻

  

* 기본값을 갖는 매개변수 선언하여 선택적으로 전달되는 아규먼트를 처리할 수 있다. 

  

* **아규먼트**의 개수와 타입을 **가변적으로 처리** 가능하며 **리턴값의 경우에도 선택적으로 처리** 가능하다. 

  ex : `cat` 함수 , `paste` 함수

  

* **함수 안**에서 만들어진 변수는 **지역변수**이며, 지역변수는 **함수내에서만 사용 가능**하다.

  **함수 안에서 만들어지지 않은 변수를 사용**할 때는 **전역 변수**를 사용하는 결과가 된다. (전역변수에도 존재하지 않으면 오류 발생)

  

* 함수 내에서 **전역변수**에 값을 저장하려는 경우 **전역 대입 연산자**로 `<<-` 을 사용한다. 

  파이썬의 global과 유사





### (5) 가변 아규먼트 함수 `(...)`

function 뒤에 `(...)`을 넣어 아규먼트를 원하는 만큼 전달할 수 있게 된다.

함수 안에서는 **벡터 혹은 리스트**를 만들어 전달받은 아규먼트를 요소로 넣는다. 


```R
# f5 함수 생성, data벡터를 만들어 전달받은 아규먼트를 요소로 넣는다. 이 때 벡터 형식으로 만들 수도 있고 리스트 형식으로 만들 수 있다. 
f5<- function(...) { print("TEST"); data <- c(...); print(length(data))}
					     
# f5 함수 호출
f5(10, 20, 30)
>	[1] "TEST"
	[1] 3

f5(“abc”, T, 10, 20)
> 	[1] "TEST"
	[1] 4
```



```R
# f6 함수 생성
f6<- function(...) {
  print("수행시작")
  data <- c(...)
  for(item in data) {
    print(item)
  }
  return(length(data))
}


# f6 함수 호출
f6()
> 	[1] "수행시작"
	[1] 0

f6(10)
> 	[1] "수행시작"
	[1] 10
	[1] 1

f6(10,20)
> 	[1] "수행시작"
	[1] 10
	[1] 20
	[1] 2

f6(10,20,30)
> 	[1] "수행시작"
	[1] 10
	[1] 20
	[1] 30
	[1] 3

f6(10,'abc', T, F)
> 	[1] "수행시작"
	[1] "10"
	[1] "abc"
    [1] "TRUE"
	[1] "FALSE"
	[1] 4
```



#### ① 벡터 저장

**벡터는 모든 원소의 타입이 동일**해야하는데, 세번째 원소인 'test'문자열이 우선순위이기 때문에 자동형번환 규칙에 의해서 모두 문자형으로 바뀌어 벡터에 저장이 된다. 

```R
# f7 함수 생성
f7<- function(...) {
  data <- c(...)
  sum <- 0;
  for(item in data) {
    if(is.numeric(item))
      sum <- sum + item
    else
      print(item)
  }
  return(sum)
}


# f7 함수 호출
f7(10,20,30) #...에 10,20,30 이 들어감. 전달된 
> [1] 60 (리턴값)

f7(10,20,'test', 30,40)
> 	[1] "10" # print(item)이 수행됨
	[1] "20"
	[1] 'test'
	[1] "30"
	[1] "40"
	[1] 0 # sum <- sum + item이 수행이 안됨. 

```



#### ② 리스트 저장

반면, **리스트는 모든 원소의 타입이 동일하지 않아도 된다.(자유롭다)** 

<u>타입을 바꾸지 않고, 저장하거나 해야할 때</u>는 자유로운 리스트를 사용한다.

```R
# f8 함수 생성
f8<- function(...) {
  data <- list(...)
  sum <- 0;
  for(item in data) {
    if(is.numeric(item))
      sum <- sum + item
    else
      print(item)
  }
  return(sum)
}


# f8 함수 호출
f8(10,20,30)
> [1] 60 (리턴값)

f8(10,20,"test", 30,40) 30 
> 	[1] 'test'
	[1] 100 (리턴값)
```





#### ③ 예제

##### ⓐ switch문과 paste()

```R
makeVector <- function(type, ...) { 
  return(switch(EXPR=type, paste0("A", c(...)), # type = 1 일때
                           paste0("B", c(...)), # type = 2 일때
                           paste0("C", c(...)), # type = 3 일때
                           paste0("D", c(...)))) # type = 4 일때
}

makeVector(type=1,1,2,3,4,5) # (키워드 아규먼트 형식) type 매개변수에 1, 1,2,3,4,5는 ... 에게 감. 
makeVector(2,100,200,300) # (포지셔널 아규먼트 형식)
makeVector(3,10,20,30,40,50,60,70,80,90)
makeVector(4,111,222,333,444,555)
```



##### ⓑ sapply(), lapply()

`sapply()` 는  lapply( )와 유사하지만 리스트 대신 행렬, 벡터 등의 데이터 타입으로 결과를 반환하는 특징이 있는 함수다. 다양한 데이터셋 중 주로 벡터를 받는다. (s는 simple을 의미함)

```R
sapply(
  X,    # 벡터, 리스트, 표현식 또는 데이터 프레임
  FUN,  # 적용할 함수
  ...,  # 추가 인자. 이 인자들은 FUN에 전달된다.
)
# 반환 값은 FUN의 결과가 길이 1인 벡터들이면 벡터, 길이가 1보다 큰 벡터들이면 행렬이다.
```



`lappy()` 는 벡터, 리스트, 표현식, 데이터 프레임 등에 함수를 적용하고 그 결과를 리스트로 반환한다. 

```R
lapply(
  X,    # 벡터, 리스트, 표현식 또는 데이터 프레임
  FUN,  # 적용할 함수
  ...   # 추가 인자. 이 인자들은 FUN에 전달된다.
)
# 반환 값은 X와 같은 길이의 리스트다.
```





```R
v <- c(10,11,20,22,30,33)
evenodd1 <- function(p) if(p %% 2 == 0) return("even") else return("odd")
> sapply(v, evenodd1) #(벡터, 함수) -> 리턴 결과를 모아 보관된 결과값은 simple 한 형태로 리턴함
[1] "even" "odd"  "even" "even" "even" "odd" 
    

> lapply(v, evenodd1) # 결과를 항상 리스트로 리턴함. 
[[1]]
[1] "even"

[[2]]
[1] "odd"

[[3]]
[1] "even"

[[4]]
[1] "even"

[[5]]
[1] "even"

[[6]]
[1] "odd"
```



### (6) 전역대입 연산

함수 안에서 변수를 만들때 **기본적으로 무조건 지역변수**를 만든다.

한편 대입연산자로`<<-`를 쓰게 되면 **전역 변수**를만들게 된다. 



### (7) invisible()

`invisible`로 리턴을 할 수는 있지만, **화면에 출력을 해주지는 않는다.** 

즉, 리턴결과를  화면에 출력하지는 않고, **그 결과를 어떠한 연산에서 사용하는 경우**에는 이를 사용한다.



### (8) Sys.sleep()

서버, 네트워크 환경의 속도가 느린 경우에는 프로그램이 빠르게 수행되는 것보다 쉬어가며 수행하는 것이 좋을 때도 있다.



### (9) 벡터만을 가져올 때 

`if(is.vector(x)  && !is.list(x))`

```R
testParamType1 <- function(x){
  result <- NULL # 조건이 모두 거짓일 때를 데비하기 위해서..
  if(is.vector(x)  && !is.list(x)) result <-"벡터를 전달했군요!" # 명확하게 벡터, 리스트 구분하기 위해 
  else if(is.data.frame(x)) result <- "데이터프레임을 전달했군요!"
  else if(is.list(x)) result <- "리스트를 전달했군요!"
  else if(is.matrix(x)) result <- "매트릭스를 전달했군요!"
  else if(is.array(x)) result <- "배열을 전달했군요!"
  # else if(is.function(x)) result <- "함수를 전달했군요!"
  return(result) # R-value 로 쓰일 때 지역변수가 없으면 전역변수를 가져온다 
}
```



### (10) stop()

에러를 발생시키고, 함수 수행을 종료함



### (11) warning()

함수 수행을 중지시키지는 않고 수행은 하지만, 경고 메세지도 출력을 함



### (12) try()

`try()`함수 안에서 함수를 호출하면, 오류가 발생했을 때 본 함수도 같이 중단되는 상황을 막을 수 있다.

**데이터 수집, 웹 크롤링**에 있어서 유연성있게 프로그램을 만들 수 있다. (특정 페이지에서 오류가 나더라도 다음 페이지에서들은 문제없이 수행되도록 하고 싶을 때)

```R
test1 <-function(p){
  cat("난 수행함\n")
  testError1(-1) # 에러 발생
  cat("나 수행할까요? \n") # testError1을 호출한 test1도 중단된다.
}
test1()

#try() 함수를 알아야 데이터 수집을 편하게 할 수 있다.
test2 <- function(p){
  cat("난 수행함\n")
  try(testError1(-1)) # test1도 같이 중단되는 상황을 방지하기 위해서는 try
  cat("나 수행할까요? \n") 
}
test2()
```



except

else

finally : 항상 시행되는.



### (13) tryCatch()



 ```R
testAll <-function(p){
  tryCatch({
    if(p=="오류테스트"){
      testError1(-1)
    }else if (p =="경고테스트"){
      testWarn(6)
    }else{
      cat("정상 수행..\n")
      print(testError1(2))
      print(testWarn(3))
    }
  },warning = function(w){ # 매개변수 warning(경고)에 함수
    print(w)
    cat("-.-;;\n")
  },error = function(e){ # 매개변수 error(오류)에 함수
    print(e)
    cat("ㅠㅠ \n")
  },finally ={ # 매개변수 finally(반드시 수행)에 수행코드
    cat("오류, 경고 발생 여부에 관계없이 반드시 수행되는 부분입니다요..\n")
  })
}
 ```



```
> testAll("오류테스트")
<simpleError in testError1(-1): 양의 값만 전달 하숑!! 더 이상 수행 안할거임..>
ㅠㅠ 
오류, 경고 발생 여부에 관계없이 반드시 수행되는 부분입니다요..
> testAll("경고테스트")
<simpleWarning in testWarn(6): 5보다 크면 안됨!! 하여 5로 처리했삼...!!>
-.-;;
오류, 경고 발생 여부에 관계없이 반드시 수행되는 부분입니다요..
> testAll("아무거나")
정상 수행..
[1] "테스트" "테스트"
[1] "테스트" "테스트" "테스트"
오류, 경고 발생 여부에 관계없이 반드시 수행되는 부분입니다요..
```





### (14) is.na()

`is.na()`는 하나의 요소만 NA인지 체크할 수 있는 함수이기 때문에 다음과 같이 여러 개의 요소가 있는 벡터를 주었을 경우, 첫번째 인덱스에서만 그 기능을 한다. 

따라서 **여러 요소가 있는 경우**에는  `any()`혹은 `all()`의 사용이 필요하다. 

```R
f.case1 <- function(x) {
  if(is.na(x)) 
    return("NA가 있슈")
  else
    return("NA가 없슈")
}


> f.case1(100)
[1] "NA가 없슈"
> f.case1(NA)
[1] "NA가 있슈"
> f.case1(1:6)
[1] "NA가 없슈"
경고메시지(들): 
In if (is.na(x)) return("NA가 있슈") else return("NA가 없슈") :
  length > 1 이라는 조건이 있고, 첫번째 요소만이 사용될 것입니다
> f.case1(c(10,20,30)) #  is.na()는 첫번째 요소만 NA 가 있는지 체크하는 하나의 값만 가지고 수행할 수 있는 함수 
[1] "NA가 없슈"
경고메시지(들): 
In if (is.na(x)) return("NA가 있슈") else return("NA가 없슈") :
  length > 1 이라는 조건이 있고, 첫번째 요소만이 사용될 것입니다
> f.case1(c(NA, 20))
[1] "NA가 있슈"
경고메시지(들): 
In if (is.na(x)) return("NA가 있슈") else return("NA가 없슈") :
  length > 1 이라는 조건이 있고, 첫번째 요소만이 사용될 것입니다
> f.case1(c(10, NA, 20))
[1] "NA가 없슈"
경고메시지(들): 
In if (is.na(x)) return("NA가 있슈") else return("NA가 없슈") :
```



#### ① any()

`any()`는 아규먼트로 주어진 함수의 결과가 **하나라도 TRUE**가 있으면(즉 is.na()의 결과가 하나라도 True 가 있으면을 의미한다.

```R
f.case2 <- function(x) {
  if(any(is.na(x))) # for 문을 안쓰고도 활용할 수 있다. any혹은 all을 통해 사용할 수 있다. 
    return("NA가 있슈")
  else
    return("NA가 없슈")
}

> f.case2(100)
[1] "NA가 없슈"
> f.case2(NA)
[1] "NA가 있슈"
> f.case2(1:6)
[1] "NA가 없슈"
> f.case2(c(10,20,30))
[1] "NA가 없슈"
> f.case2(c(NA, 20))
[1] "NA가 있슈"
> f.case2(c(10, NA, 20))
[1] "NA가 있슈"
```



#### ② all()

`all()`은 아규먼트로 주어진 함수의 결과가 **모두가  TRUE**가 임을 의미한다.

```R
f.case3 <- function(x) {
  if(all(is.na(x))) 
    return("모두 NA임")
  else
    return("모두 NA인 것은 아님")
}
f.case3(100)
f.case3(LETTERS)
f.case3(NA)
f.case3(c(NA, NA, NA))
f.case3(c(NA, NA, 10))
```










## 7) 파일 읽어오기

R 에서는 csv, txt, xml, json, xslx, pdf 와 같은 다양한 파일을 읽어올 수 있다.

(csv,txt는 기본적으로 R에서 지원하지만, 나머지 형식의 파일은 추가 패키지를 설치하여 읽어올 수 있다.)



### (0) 디렉토리 확인

```R
getwd()  # getwd : getworkingdirectioy
setwd('xxx') 
```



### (1) read.csv() : 데이터 프레임 (csv 파일)

```R
read.csv("data/score.csv") # 상대주소
read.csv("c:/jsy/Rexam/data/score.csv") # 절대주소
```

```R
read.csv(file.choose())
> 파일 선택 창이 뜸
```



### (2) read.table() : 데이터 프레임 (log 파일)

 `read.table`은 자동적으로 **V1,V2로 컬럼명을 자동적으로 붙인다.**

```R
df2 <- read.table("data/product_click.log", stringsAsFactors = T) #read.csv와 거의 동일
```



|                read.csv                 |                          read.table                          |
| :-------------------------------------: | :----------------------------------------------------------: |
|  각각의 내용이 **컴마**로 구분된 파일   | 구분자가 <u>컴마가 아닌</u> **다른 문자(탭, 공백)** 으로 구분된 파일 |
| 기본적으로 첫 행을 컬럼명으로 인식한다. |        기본적으로 첫 행을 컬럼명으로 인식하지 않는다.        |





### (3) scan() : txt 파일

`scan()` 함수는 데이터 프레임이 아닌 `벡터`로 데이터를 불러온다.

`txt` 파일을 읽어올 수 있다.



#### ① 수치 데이터

`scan`함수는 수치 데이터를 읽는데 특화되어 있다. (기본값)

```R
nums <- scan("data/sample_num.txt")
```



#### ② 문자 데이터

`scan` 함수에서`what` 매개변수에 NULL을 주면 문자 데이터를 읽어올 수 있다.

```R
word_ansi <- scan("data/sample_ansi.txt",what="")
```



##### ⓐ UTF-8 (인코딩 매개변수 설정 필수 )

인코딩이 UTF-8로 되어있으면 유니코드로 저장된다.

`encoding` 매개변수에 UTF-8을 준다. 

만약 인코딩 정보를 주지 않는다면(생략하면), OS(운영체제)의 고유 코드셋 정보를 반영하여 읽어온다. windows 10의 고유 코드셋은 CP949(ANSI) 이기 때문에, 한글 깨짐 현상이 발생한다. 

```R
words_utf8 <- scan("data/sample_utf8.txt", what="",encoding="UTF-8")
words_utf8_new <- scan("data/sample_utf8.txt", what="")
```



##### ⓑ ANSI

유니코드가 아니라 우리나라 고유의 코드 체계로 저장된다.

각 나라마다 그 나라 고유의 코드셋이 있으며, 코드셋은 컴퓨터에서 문자를 표현하기 위해 문자마다 부여한 숫자값이다.

0x00~0x7F는 ASCII 코드 값이라고 하여 전세계의 표준이다. (숫자, 영문자, 대소문자, 특수기호) 우리나라는 0xB0A1 (가)  부터 (힣) 까지의 고유 코드값은 KSC5601, EUC-KR, CP949, ANSI 의 이름을 갖는다.

```R
word <- scan("data/sample_ansi.txt",what="")
```





### (4) readLines()

`readLines()`함수는 행 단위로 읽어 원소로 저장한다. (각각의 행 단위의 데이터)

`벡터`로 데이터를 불러온다. 

```R
lines_ansi <- readLines("data/sample_ansi.txt")
lines_utf8 <- readLines("data/sample_utf8.txt",encoding="UTF-8")
```





 ## 8) 사분위수

자료를 크기 순으로 배열하고, 누적 백분율을 4 등분한 각 점에 해당하는 값을 말한다. 제1사분위수는 누적 백분율이 25%에 해당하는 점수이고, 제2사분위수는 누적 백분율이 50%, 제3사분위수는 75%, 제4사분위수는 100%에 해당하는 점수이다. 특히 제2사분위수는 누적 백분율이 50%이므로 개념적으로 중앙값과 동일하다.

 

![https://mblogthumb-phinf.pstatic.net/20150702_229/jevida_1435803723327eyeeG_PNG/3.png?type=w2](file:///C:/Users/user/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

 

홀수 갯수의 숫자들에 대한 사분위수 계산은 간단하다.

전체에서 중간값 : 2/4 분위수

2/4 분위수를 기준)으로 양쪽에서 중간값을 구하면 1/4, 3/4 분위수 값이 된다. 이 때 2/4 분위수의 값을 포함해서 처리한다.

 

| 데이터들                            |  0%  |              25%              | 50%  |               75%               | 100% |
| ----------------------------------- | :--: | :---------------------------: | :--: | :-----------------------------: | :--: |
| c(1,2,3,4,5)                        |  1   |       1,2,3의 중간값 2        |  3   |        3,4,5의 중간값 4         |  5   |
| c(1,2,3,4,5,6,7)                    |  1   |     1,2,3,4의 중간값 2.5      |  4   |      4,5,6,7의 중간값 5.5       |  6   |
| c(1,2,3,4,5,6,7,8,9)                |  1   |    1,2,3,4,5의 중간값   3     |  5   |      5,6,7,8,9의 중간값 7       |  9   |
| c(1,2,3,4,5,6,7,8,9,10,11)          |  1   |   1,2,3,4,5,6의 중간값  3.5   |  6   |   6,7,8,9,10,11의 중간값 8.5    |  11  |
| c(2,4,6,8,10)                       |  2   |       2,4,6의 중간값  4       |  6   |        6,8,10의 중간값 8        |  10  |
| c(2,10,16,28,30)                    |  2   |     2,10,16의 중간값  10      |  16  |      16,28,30의 중간값 28       |  30  |
| c(2,10,15,28,30,40,45)              |  2   |   2,10,15,28의 중간값 12.5    |  28  |     28,30,40,45의 중간값 35     |  4   |
| c(10,12,18,20,25,26,30,32,33,40,50) |  10  | 10,12,18,20,25,26의 중간값 19 |  26  | 26,30,32,33,40,50의 중간값 32.5 |  50  |

 

 

짝수 갯수의 숫자들에 대한 사분위수 계산은 다음과 같다.

2/4 분위수(중간값) : 중앙의 2개 값의 평균

1/4 분위수 : 중간값의 왼쪽 데이터들

​      홀수 갯수 : 중간값 + (중간값의 다음값 - 중간값) * 0.25 

​      짝수 갯수 : 중간값 + (큰값 - 작은값) * 0.25

3/4 분위수 : 중간값의 왼쪽 데이터들

​      홀수 갯수 : 중간값 - (중간값 - 중간값 이전값) * 0.25 

​      짝수 갯수 : 중간값 - (큰값 - 작은값) * 0.25

 

| 데이터들                               |  0%  |                          25%                           | 50%  |                          75%                           | 100% |
| -------------------------------------- | :--: | :----------------------------------------------------: | :--: | :----------------------------------------------------: | :--: |
| c(1,2,3,4)                             |  1   |      1,2 짝수식 (1+2)/2 +(2-1)*0.25          1.75      | 2.5  |       3,4 짝수식  (3+4)/2-(4-3)*0.25        3.25       |  4   |
| c(1,2,3,4,5,6)                         |  1   |       1,2,3 홀수식  2+(3-2)*0.25            2.25       | 3.5  |        4,5,6 홀수식 5-(5-4)*0.25           4.75        |  6   |
| c(1,2,3,4,5,6,7,8)                     |  1   |     1,2,3,4 짝수식 (2+3)/2+(3-2)*0.25        2.75      | 4.5  |     5,6,7,8 짝수식  (6+7)/2-(7-6)*0.25       6.25      |  8   |
| c(1,2,3,4,5,6,7,8,9,10)                |  1   |      1,2,3,4,5 홀수식  3+(4-3)*0.25          3.25      | 5.5  |       6,7,8,9,10 홀수식 8-(8-7)*0.25        7.75       |  10  |
| c(2,4,6,8,10,12)                       |  2   |        2,4,6 홀수식 4+(4-2)*0.25           4.5         |  7   |       8,10,12 홀수식 10-(10-8)*0.25          9.5       |  12  |
| c(2,5,10,15,18,20)                     |  2   |      2,5,10 홀수식  5+(10-5)*0.25           6.25       | 12.5 |     15,18,20 홀수식 18-(18-15)*0.25         17.25      |  20  |
| c(2,3,10,15,50,100)                    |  2   |       2,3,10 홀수식  3+(10-3)*0.25          4.75       | 12.5 |     15,50,100 홀수식 50-(50-15)*0.25        41.25      | 100  |
| c(1,2,10,14,15,16,27,38)               |  1   |      1,2,10,14 짝수식 (2+10)/2+(10-2)*0.25      8      | 14.5 |  15,16,27,38 짝수식  (16+27)/2-(27-16)*0.25    18.75   |  38  |
| c(24,25,26,27,30,32,40,44,50,52,55,57) |  24  | 24,25,26,27,30,32 짝수식 (26+27)/2+(27-26)*0.25  26.75 | 35.5 | 40,44,50,52,55,57  짝수식 (50+52)/2-(52-50)*0.25  50.5 |  57  |

